<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 cap-slider.glb -t -u -T --draco draco
-->

<script lang="ts">
	import type * as THREE from 'three';

	import { onMount, type Snippet } from 'svelte';
	import { T, useTask, useThrelte, type Props } from '@threlte/core';
	import { useGltf, useSuspense, useDraco, Outlines, useCursor } from '@threlte/extras';
	import { base } from '$app/paths';
	import { Euler, Quaternion, Vector2 } from 'three';
	const { onPointerEnter, onPointerLeave } = useCursor();

	let {
		fallback,
		error,
		children,
		ref = $bindable(),
    color = '#0e7490',
		...props
	}: Props<THREE.Group> & {
		ref?: THREE.Group;
		children?: Snippet<[{ ref: THREE.Group }]>;
		fallback?: Snippet;
		error?: Snippet<[{ error: Error }]>;
    color?: string;
	} = $props();

	const suspend = useSuspense();

	type GLTFResult = {
		nodes: {
			['slider-cap']: THREE.Mesh;
		};
		materials: {};
	};

	const gltf = suspend(
		useGltf<GLTFResult>(base + '/cap-slider-transformed.glb', {
			dracoLoader: useDraco(base + '/draco/')
		})
	);


	const maxSpeed = 0.03;
	const acceleration = 0.002;
	const damping = 0.96;

	let isDragging = false;
	let previousPointerPosition = new Vector2();
	let velocity = new Vector2();
	let totalMove = new Vector2();

	let quaternion = new Quaternion();

	useTask((delta) => {
		if (!ref) return;

		velocity.multiplyScalar(damping);

		let rotate = 0;

		// const deltaRotationQuaternion = new Quaternion().setFromEuler(
		// 	new Euler(velocity.y * delta * 120 * 0, (velocity.x + rotate) * delta * 120, 0, 'XYZ')
		// );
		// quaternion.multiplyQuaternions(deltaRotationQuaternion, quaternion);

		// ref.quaternion.copy(quaternion);

    // ref.position.x = totalMove.x;
    ref.position.x += (velocity.y * delta) * 200;


    let max = 3.2;

    ref.position.x = Math.max(Math.min(ref.position.x, max), -max);
	});

	const onPointerMove = (event: PointerEvent | TouchEvent) => {
		if (!isDragging) return;
		event.preventDefault();

		let clientX = 0,
			clientY = 0;
		if (window.TouchEvent && event instanceof TouchEvent) {
			clientX = event.touches[0].clientX;
			clientY = event.touches[0].clientY;
		} else if (event instanceof PointerEvent) {
			clientX = event.clientX;
			clientY = event.clientY;
		}

		const deltaMove = new Vector2(
			clientX - previousPointerPosition.x,
			clientY - previousPointerPosition.y
		);
		totalMove.add(deltaMove);

		velocity.x += deltaMove.x * acceleration;
		velocity.y += deltaMove.y * acceleration;

		// Limit the speed
		if (velocity.length() > maxSpeed) {
			velocity.normalize().multiplyScalar(maxSpeed);
		}

		previousPointerPosition.set(clientX, clientY);
	};

	const onPointerDown = (event: PointerEvent | TouchEvent) => {
		isDragging = true;
		let clientX = 0,
			clientY = 0;
		if (window.TouchEvent && event instanceof TouchEvent) {
			clientX = event.touches[0].clientX;
			clientY = event.touches[0].clientY;
		} else if (event instanceof PointerEvent) {
			clientX = event.clientX;
			clientY = event.clientY;
		}
		previousPointerPosition.set(clientX, clientY);
		totalMove.set(0, 0);

		if (window.TouchEvent && event instanceof window.TouchEvent) {
			event.preventDefault();
		}
	};

	const onPointerUp = (event) => {
		isDragging = false;

		totalMove.set(0, 0);
	};

	const { renderer } = useThrelte();

	onMount(() => {
		const canvas = renderer.domElement;

		canvas.addEventListener('pointermove', onPointerMove, { passive: false });
		canvas.addEventListener('pointerup', onPointerUp, false);
		canvas.addEventListener('touchmove', onPointerMove, { passive: false });
		canvas.addEventListener('touchend', onPointerUp, false);

		return () => {
			canvas.removeEventListener('pointermove', onPointerMove, false);
			canvas.removeEventListener('pointerup', onPointerUp, false);
			canvas.removeEventListener('touchmove', onPointerMove, false);
			canvas.removeEventListener('touchend', onPointerUp, false);
		};
	});
</script>

<T.Group bind:ref dispose={false} {...props}>
	{#await gltf}
		{@render fallback?.()}
	{:then gltf}
		<T.Mesh scale={0.1} 
    onpointerdown={(evt: any) => {
      evt.stopPropagation();
      onPointerDown(evt);
    }}
    onpointerleave={() => {
      // sizeSpring.set(1.5);
      onPointerLeave();
    }}
    onpointerenter={() => {
      // sizeSpring.set(1.6);
      onPointerEnter();
    }}
    ontouchstart={(evt: any) => {
      evt.stopPropagation();
      onPointerDown(evt);
    }}
    ontouchend={(evt: any) => {
      onPointerUp(evt);
    }}>
			<T is={gltf.nodes['slider-cap'].geometry} />
			<T.MeshToonMaterial color={color} />
			<Outlines color="white" width={2} angle={1} />
		</T.Mesh>
	{:catch err}
		{@render error?.({ error: err })}
	{/await}

	{@render children?.({ ref })}
</T.Group>
